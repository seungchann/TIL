# C programming 포인터  
## Contents  
* [포인터 사용하기](#0-포인터-사용하기)  
* [포인터 변수 선언하기](#1-포인터-변수-선언하기)  
* [역참조 연산자 사용하기](#2-역참조-연산자-사용하기)  

## 0. 포인터 사용하기  
### 변수의 메모리 주소  
* 우리는 값을 저장할 때 변수를 사용합니다.  
* 변수는 어디에 생길까요?  
```c
int num1 = 10;
```
* 다음과 같이 변수는 **컴퓨터의 메모리**에 생성됩니다.  
* 메모리에 일정한 공간을 확보해두고 원하는 값을 저장하거나 가져오는 방식입니다.  

![메모리와 변수](https://dojang.io/pluginfile.php/337/mod_page/content/21/unit34-1.png)  

* 보통 변수는 `num1`과 같이 이름으로 사용합니다.  
* 하지만 메모리의 특정 장소에 위치하고 있으므로, 메모리 주소로도 표현할 수 있습니다.  
* 변수의 메모리 주소는 다음과 같이 구할 수 있습니다.  
```c
#include <stdio.h>

int main() {

  int num1 = 10;

  printf("%p\n", &num1); // 008AF7FC: num1의 메모리 주소를 출력
                         // 컴퓨터마다, 실행할 때마다 달라짐
  
  return 0
}

// 실행 결과
008AF7FC (메모리 주소. 컴퓨터마다, 실행할 때마다 달라짐)
```

* 변수의 메모리 주소를 구할 때는 변수 앞에 & (주소 연산자)를 붙이면 됩니다.  
* 메모리 주소는 16진수 형태이며, `printf`에서 서식 지정자 `%p`를 사용하여 출력합니다.  
* 메모리 주소는 고정된 것이 아니라 컴퓨터마다, 실행할 때마다 달라집니다.  

![변수의 메모리 주소](https://dojang.io/pluginfile.php/337/mod_page/content/21/unit34-2.png)  

## 1. 포인터 변수 선언하기  
* 메모리 주소는 포인터(pointer) 변수에 저장합니다.  
* 다음과 같이 포인터 변수는 `*`를 사용하여 선언합니다.  
  * 자료형 `* 포인터이름`;  
  * 포인터 = &변수;

```c
#include <stdio.h>

int main() {
  int *numPtr; // 포인터 변수 선언
  int num1 = 10; // int형 변수를 선언하고 10 저장
  
  numPtr = &num1; // num1의 메모리 주소를 포인터 변수에 저장
  
  printf("%p\n", numPtr); // 0055FC24: 포인터 변수 numPtr의 값 출력
                          // 컴퓨터마다, 실행할 때마다 달라짐  
  printf("%p\n", &num1); // 0055FC24: 변수 num1의 메모리 주소 출력
                         // 컴퓨터마다, 실행할 때마다 달라짐
                         
  return 0;
}

// 실행 결과
0055FC24 (메모리 주소. 컴퓨터마다, 실행할 때마다 달라짐)
0055FC24 (메모리 주소. 컴퓨터마다, 실행할 때마다 달라짐)
```
* 포인터 변수를 선언할 때는 자료형 뒤에 `*` (Asterisk, 애스터리스크)를 붙입니다.  
* `*`의 위치에 따른 차이는 없으며 모두 같은 뜻입니다.  

```c
int* numPtr; // 자료형 쪽에 *을 붙임
int * numPtr; // 자료형과 변수 가운데 *를 넣음
int *numPtr; // 변수 쪽에 *을 붙임
```

* 포인터 변수를 선언했으면 다음과 같이 &로 변수의 주소를 구해서 포인터 변수에 저장합니다.  
```c
numPtr = &num1; // num1의 메모리 주소를 포인터 변수에 저장  
```

* 이제 printf로 포인터 numPtr의 값을 출력해보면 변수 num1의 메모리 주소가 나옵니다.  
* 즉, 포인터와 메모리 주소는 같은 의미입니다.  
```c
printf("%p\n", numPtr); // 0055FC24: 포인터 변수 numPtr의 값 출력
                        // 컴퓨터마다, 실행할 때마다 달라짐
printf("%p\n", &num1);  // 0055FC24: 변수 num1의 메모리 주소 출력
                        // 컴퓨터마다, 실행할 때마다 달라짐
```
* 포인터 변수를 선언할 때는 자료형을 알려주고 `*`를 붙이는 방식을 사용합니다.  
* 여기서 `int *`는 영어로 pointer to int라고 읽는데, int형 공간을 가리키는 포인터라는 뜻입니다. (int 포인터라고도 부릅니다.)  

![int 포인터](https://dojang.io/pluginfile.php/338/mod_page/content/23/unit34-3.png)  
* 다음과 같이 포인터는 메모리의 특정 위치를 가리킬 때 사용합니다.  

![포인터와 메모리](https://dojang.io/pluginfile.php/338/mod_page/content/23/unit34-4.png)  

```c
int *numPtr; // 포인터 변수 선언
int num1 = 10;

numPtr = &num1; // num1의 메모리 주소를 포인터 변수에 저장 
```
* numPtr은 10이 저장된 메모리 공간을 가리킵니다.  
* 즉, 변수 num1이 있는 공간을 가리키게 되는 것입니다.  
![포인터에 변수의 메모리 주소 할당](https://dojang.io/pluginfile.php/338/mod_page/content/23/unit34-5.png)  

## 2. 역참조 연산자 사용하기  
* 포인터 변수에는 메모리 주소가 저장되어 있습니다.  
* 메모리 주소가 있는 곳으로 이동해서 값을 가져오고 싶다면 역참조(dereference) 연산자 `*`를 사용합니다.  
```c
#include <stdio.h>

int main() {
  int *numPtr; // 포인터 변수 선언
  int num1 = 10; // 정수형 변수를 선언하고 10 저장
  
  numPtr = &num1; // num1의 메모리 주소를 포인터 변수에 저장  
  
  printf("%d\n", *numPtr); // 10: 역참조 연산자로 num1의 메모리 주소에 접근하여 값을 가져옴  
  
  return 0;
}

// 실행 결과
10
```

* 역참조 연산자 `*`는 포인터 앞에 붙입니다.  
* 다음과 같이 numPtr앞에 `*`를 붙이면, numPtr에 저장된 메모리 주소로 가서 값을 가져옵니다.  
* 여기서는 numPtr이 num1의 메모리 주소를 저장하고 있으므로, num1의 값인 10이 출력됩니다.  
* 즉, 포인터는 변수의 주소만 가르키며 역참조는 주소의 접근하여 값을 가져옵니다.  

![](https://dojang.io/pluginfile.php/339/mod_page/content/30/unit34-6.png) 

### 포인터 선언과 역참조?  
* 포인터를 선언할 때도 `*`를 사용하고 역참조를 할 때도 `*`를 사용합니다.  
* 같은 `*` 기호를 사용해서 헷갈리기 쉽지만 선언과 사용을 구분해서 생각하면 됩니다.  
```c
int *numPtr; // 포인터. 포인터를 선언할 때 *
printf("%d\n", *numPtr); // 역참조. 포인터에 사용할 때 *
```

* 이번에는 포인터 변수에 역참조 연산자를 사용한 뒤 값을 저장(할당)해보겠습니다.  
```c
#include <stdio.h>

int main() {
  int *numPtr; // 포인터 변수 선언
  int num1 = 10; // 정수형 변수를 선언하고 10 저장
  
  numPtr = &num1; // num1의 메모리 주소를 포인터 변수에 저장
  
  *numPtr = 20 // 역참조 연산자로 메모리 주소에 접근하여 20을 저장
  
  printf("%d\n", *numPtr); // 20: 역참조 연산자로 메모리 주소에 접근하여 값을 가져옴
  printf("%d\n", num1); // 20: 실제 num1의 값도 바뀜
  
  return 0;
}

// 실행 결과
20
20
```

* 역참조 연산자는 값을 가져올 수도 있고 값을 저장할 수도 있습니다.  
* 여기서는 `*numPtr = 20;`과 같이 numPtr에 저장된 메모리 주소에 접근하여 20을 저장했습니다.  
* 또 한가지 중요한 점은 `*numPtr = 20;`으로 20을 저장한 뒤 num1 값을 출력해보면 20이 나온다는 것입니다.  
* 왜냐하면 numPtr에는 num1의 메모리 주소가 저장되어 있으므로 역참조 연산자로 값을 저장하면 결국 num1에 저장하게 됩니다.  

![](https://dojang.io/pluginfile.php/339/mod_page/content/30/unit34-7.png)  

* 역참조 연산자는 자료형을 바꾸는 효과를 냅니다.  
* 즉, `int *numPtr;`에서 `*numPtr`처럼 역참조하면 pointer to int에서 그냥 int로 만듭니다. (int 포인터 -> int)  
* 만약 포인터 numPtr에 변수 num1을 할당한다면 역참조 연산자로 자료형을 맞춰주면 됩니다.  
```c
int *numPtr;
int num1 = 10;

numPtr = num1; // 컴파일 경고, numPtr은 int 포인터형이고, num1은 int형이라 자료형이 일치하지 않음

*numPtr = num1; // *numPtr은 int형이고 num1도 int형이라 자료형이 일치함
```

* 물론 주소 연산자 `&`도 자료형을 맞춰주는 역할을 합니다.
* `&`을 붙이지 않으면 앞과 같은 경고가 발생합니다.  
```c
int *numPtr;
int num1;

numPtr = &num1 // numPtr은 int 포인터형이고, &num1은 int형 변수의 주소이므로 자료형이 일치함  
               // numPtr은 pointer to int, &num1은 address to int이므로 자료형이 일치함
```

* 즉, pointer to int와 address of int는 자료형이 같습니다.  
![포인터 자료형](https://dojang.io/pluginfile.php/339/mod_page/content/30/unit34-8.png)  

### 변수, 주소 연산자, 포인터의 차이  

![변수, 주소 연산자, 포인터의 차이](https://dojang.io/pluginfile.php/339/mod_page/content/30/unit34-9.png)  

#### 변수
* 메모리 주소를 몰라도 값을 가져오거나 저장할 수 있습니다.  
* 그냥 변수에 값을 할당하거나 그대로 출력하면 됩니다.  

#### 주소 연산자 `&`  
* 변수의 메모리 주소를 구합니다.  
* 이 그림에서 10을 감싸고 있는 상자는 메모리 공간을 뜻하는데, 주소 연산자는 메모리 공간이 어디에 있는지 위치만 알아낼 수 있습니다.  

#### 역참조 연산자 `*`  
* 그림에서 보면 상자 안까지 들어가서 값을 가져오거나 저장합니다.  
* 즉, 메모리 주소를 알고 있으므로 메모리 주소를 거쳐서 그 안에 있는 값을 가져오거나 저장합니다.  

#### 포인터  
* 변수의 메모리 주소만 가리킵니다.  
* 따라서 포인터는 메모리 공간이 어디에 있는지 위치만 알고 있습니다.  
