# Chapter 08. 구조체와 클래스: 객체지향 스위프트  
> *'꼼꼼한 재은 씨의 Swift: 문법편 - 이재은'* 내용을 참고하여 정리한 게시글입니다.  

## 들어가기 전에...  
> 나중에 구조체와 클래스에 대한 학습을 마치고 나면 다시 여기로 돌아와 읽어보기 바랍니다.  
* 개념적으로 구조체와 클래스는 하나의 큰 **코드 블록**이다.  
* 이들 객체는 스위프트가 언어적으로 유연성을 가질 수 있게 해준다.  
* **유연성** : 코드를 떼어서 다른 곳으로 옮기거나 새로운 코드를 추가하기가 쉽다 (<-> 의존성)
<br></br>
* **프로퍼티 (Properties)** : 구조체와 클래스 내부에서 정의된 변수와 상수  
* **메소드 (Method)** : 클래스 내부에서 정의된 함수  
* **멤버 (Member)** : 프로퍼티 + 메소드  
### 구조체 vs 클래스  
#### 공통점  
* 변수나 상수를 사용하여 값을 저장하는 **프로퍼티**를 정의할 수 있음  
* 함수를 사용하여 기능을 제공하는 **메소드**를 정의할 수 있음  
* 속성값에 접근할 수 있는 방법을 제공하는 **서브스크립트**를 정의할 수 있음  
* 객체를 원하는 초기 상태로 설정해주는 **초기화 블록**을 정의할 수 있음  
* 객체에 함수적 기능을 추가하는 **확장(extend)** 구문을 정의할 수 있음  
* 특정 형식의 함수적 표준을 제공하기 위한 **프로토콜**을 구현할 수 있음  
#### 차이점  
* **상속** : 클래스의 특성을 다른 클래스에게 물려줄 수 있다.  
* **타입 캐스팅** : 실행 시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사할 수 있다.  
* **소멸화 구문** : 인스턴스가 소멸되기 직전에 처리해야 할 구문을 미리 등록해 놓을 수 있다.  
* **참조에 의한 전달** : 클래스 인스턴스가 전달될 때에는 참조 형식으로 제공되며, 이때 참조가 가능한 개수는 제약이 없다.  

## 8.1 구조체와 클래스의 기본 개념  
### 8.1.1 정의 구문  
* 구조체는 `struct` 키워드를 사용하여 정의  
* 클래스는 `class` 키워드를 사용하여 정의  

```swift
struct Resolution {
    // 구조체 내용이 들어갈 부분
}
```

```swift
class VideoMode {
    // 클래스 내용이 들어갈 부분
}
```
* 구조체/클래스 이름의 첫 글자는 **대문자**로, 나머지 글자는 **소문자**로 작성하는 것이 원칙이다.  
* 스위프트에서 구조체나 클래스, 열거형, 프로토콜 등 객체는 **대문자로 시작하는 카멜(Camel) 표기법**을 사용하는 것이 원칙이다.  
* 객체 내에서 프로퍼티나 메소드를 선언할 떄는 **소문자로 시작하는 카멜 표기법**을 사용한다.  

```swift
// 첫 글자는 대문자로 시작
struct Integer {...}
struct String {...}
class Object {...}
class Controller {...}

// 2단어 이상일 경우 카멜 표기법  
struct SignedInteger {...}
class ViewController {...}

// 약어로 이루어진 부분은 모두 대문자로 표기  
class NSNumber {...}
class UIView {...}
struct JSONDictionary {...}
```

### 8.1.2 메소드와 프로퍼티  
* 프로퍼티 (Property) : 구조체와 클래스 내부에서 정의된 **변수나 상수**  
* 메소드 (Method) : 구조체와 클래스 내부에서 **정의된 함수**  

```swift
struct Resolution {
    var width = 0
    var height = 0
    
    func desc() -> String {
        return "Resolution 구조체"
    }
}

class VideoMode {
    var interlaced = false
    var frameRate = 0.0
    var name : String?
    
    func desc() -> String {
        return "VideoMode 클래스"
    }
}
```

### 8.1.3 인스턴스  
* 우리가 정의한 구조체나 클래스를 **그대로 사용**해서 값을 저장하거나 메소드를 실행할 수는 없다.  
* 실질적인 값을 저장하고 사용하려면 **메모리 공간을 할당받은 객체**가 필요하다.  
* 구조체나 클래스는 값을 담을 수 있는 실질적인 그릇을 만들기 위한 일종의 틀이다. -> **원형 (Origin)**  
* 이때 원형 틀을 이용하여 찍어낸 그릇을 **인스턴스 (Instance)**라고 한다.  
```swift
// Resolution 구조체에 대한 인스턴스를 생성하고 상수 insRes에 할당
let insRes = Resolution()

// VideoMode 클래스에 대한 인스턴스를 생성하고 상수 insVMode에 할당  
let insVMode = VideoMode()
```

* 위 예제에서 선언된 프로퍼티는 오직 인스턴스를 통해서만 접근할 수 있다.  
* 이 때문에 구조체나 클래스의 이름을 통해서는 프로퍼티에 접근할 수 었다.  
```swift
lef width = insRes.width
print("insRes 인스턴스의 width 값은 \(width)입니다.)

// 실행 결과
insRes 인스턴스의 width 값은 입니다.
```

* 만약 객체에 정의된 프로퍼티가 **서브 프로퍼티**를 가지고 있는 객체라면, 다음과 같이 계속 점 구문을 이용하여 단계적으로 접근할 수 있다.  
```swift
class VideoMode {
    var interlaced = false
    var frameRate = 0.0
    var name: String?
    
    var res = Resolution()
    ...
}

// VideoMode 클래스에 대한 인스턴스를 생성하고 상수에 할당  
let vMode = VideoMode()

print("vMode 인스턴스의 width 값은 \(vMode.res.width) 입니다.")

// 실행 결과
vMode 인스턴스의 width 값은 입니다.
```

* 프로퍼티의 하위 프로퍼티에 값을 할당할 때도 위와 같이 점 구문을 연속으로 연결하여 값을 할당할 수 있다.  
* 이러한 방식을 **체인 (Chain)** 이라고 한다.  
* Objective-C에서는 이와 같은 체인 형식을 지원하지 않는다.  
* 스위프트에서는 연속된 프로퍼티의 타입을 컴파일러가 모두 체크한다. -> 체인 형식 사용 가능  

### 8.1.4 초기화  
* **옵셔널 타입으로 선언되지 않은 모든 프로퍼티**는 명시적으로 초기화해 주어야 한다.  
* 명시적인 초기화란?  
  * 1. 프로퍼티를 선언하면서 동시에 초기값을 지정하는 경우  
  * 2. 초기화 메소드 내에서 프로퍼티 초기값을 지정하는 경우  
* 클래스나 구조체의 모든 프로퍼티는 적어도 **인스턴스가 생성되는 시점**까지는 반드시 초기화되어야 한다.  
* 옵셔널 타입을 선언된 프로퍼티는 초기값이 지정되지 않을 경우 자동으로 **nil**로 초기화된다.  
* **구조체**는 모드 프로퍼티의 값의 인자값으로 입력받아 초기화하는 **기본 초기화 구문**을 자동으로 제공한다.  
* **멤버와이즈 초기화 구문 (Memberwise Initializer)** 라고 부른다.  

```swift
// width와 height르 매개변수로 하여 Resolution 인스턴스를 생성
let defaultRes = Resolution(width: 1024, height: 768)
```
* 이처럼 멤버 와이즈 초기화 구문은 인스턴스를 생성하는 형식을 정의하고, 입력된 인자값을 이용하여 프로퍼티를 초기화하는 과정까지 알아서 처리한다.  
* **클래스**는 멤버와이즈 형식의 초기화 구문이 제공되지 않는다.  
* 일부 프로퍼티의 초기값이 지정되지 않았을 경우, 초기화 구문 내에서에서 프로퍼티가 초기화될 수 있도록 직접 처리해주면 된다.  
* 완전 이해되기 전까지는 **클래스**의 프로퍼티와 초기화 구문에 대해 가급적 다음의 두 가지 원칙을 지키는 것이 좋다.  
  * 1. 모든 프로퍼티는 정의할 때 초기값을 주던가, 아니면 옵셔널 타입으로 선언한다.  
  * 2. 인스턴스를 생성할 때에는 클래스명 뒤에 `()`를 붙여준다.  

### 8.1.5 구조체의 값 전달 방식: 복사에 의한 전달  
* **구조체**와 **클래스**의 결정적 차이 중의 하나가 **값을 전달하는 방식**이다.   
* **구조체** 인스턴스를 생성한 후 이를 변수나 상수에 할당하거나, 함수의 인자값을 전달할 때 **값을 복사하여 전달**  
* **값 타입 (Value Type)**, 또는 복사에 의한 전달  
* 스위프트에서 제공하는 **정수, 문자열, 배열, 딕셔너리, 열거형** 등 기본 자료형들은 모두 복사를 통해 값이 전달됨 -> 자료형이 **구조체**로 구현되었기 때문  
* 인스턴스를 변수에 대입하면 기존의 인스턴스가 그대로 대입되는 것이 아님 -> 이를 **복사한 새로운 값**이 대입됨  
* 기존 인스턴스나 할당된 쪽의 인스턴스에 무언가 변경이 발생해도, 서로에게 **전혀 영향을 미치지 않는다.**  
```swift
let hd = Resolution(width: 1920, height: 1080)
var cinema = hd
cinema.width = 2048
print("cinema 인스턴스의 width 값은 \(cinema.width)입니다.")
print("hd 인스턴스의 width 값은 \(cinema.width)입니다.")

// 실행 결과
cinema 인스턴스의 width 값은 2048 입니다.
hd 인스턴스의 width 값은 1920 입니다.
```

### 8.1.6 클래스의 값 전달 방식: 참조에 의한 전달  
* **클래스**는 **메모리 주소 참조에 의한 전달 방식**을 사용한다.  
* **참조 타입 (Reference Type)**이라고 한다.  
* **참조 타입**은 변수나 상수에 할당될 때, 또는 함수의 인자값으로 전달될 때 **값의 복사가 이루어지지 않는다.**  
* 참조 -> 인스턴스가 저장된 **메모리 주소**가 전달된다는 뜻  
* 스위프트 내부적으로 **참조에 대한 객체를 직접 불러오기 때문에**, 실제로 주고받는 값이 참조일 뿐이라는 것을 거의 체감할 수 없다.  
* 스위프트에서는 포인터를 사용하여 객체와 메모리 주소를 구분하는 대신, **클래스 타입일 경우 항상 메모리 주소를 사용하여 객체 자체를 전달**한다.  
```swift
let video = VideoMode()
video.name = "Original Video Instance"

let dvd = video
dvd.name = "DVD Video Instance"
print("video 인스턴스의 name 값은 \(video.name!)입니다.")

// 실행 결과
video 인스턴스의 name 값은 DVD Video Instance입니다.
```
* 인스턴스의 값을 함수의 인자값으로 넣어 다시 수정하면  
```swift
func changeName(v: VideoMode) {
    v.name = "Function Video Instance"
}

changeName(v: video)
print("video 인스턴스의 name 값은 \(video.name!)입니다.")

// 실행 결과
video 인스턴스의 name 값은 Function Video Instance입니다.  
```

* 위의 예시만 하더라도 `VideoMode()` 인스턴스 하나에 대해 `video 상수, dvd 상수, v 매개변수` 등 세 곳에서 동시에 참조하고 있다.  
* 클래스에서는 **메모리에 대한 이슈 문제**가 부각된다.  
* 적절한 메모리 해제 시점을 계산해야 한다.  
* 언제나 단일 참조가 보장되는 **구조체** 인스턴스는 할당된 변수나 상수의 사용이 끝나면 곧바로 메모리에서 해제해도 된다.  
* **클래스** 인스턴스는 여러 곳에서 동시에 참조가 가능하므로 한 곳에서의 참조가 완료되었다고 해도 **마음대로 메모리에서 해제할 수 없다.**  
* 다른 곳에서 해당 인스턴스를 계속 참조하고 있을 가능성이 있다.  
* 그냥 인스턴스를 해제해버리면, **잘못된 메모리 참조**로 인한 오류가 발생한다.  
* 이로 인해 여러 가지 문제가 생겨나다 보니 스위프트에서는 **ARC**를 도입했다.  
  * **ARC (Auto Reference Counter)** : 지금 클래스 인스턴스를 참조하는 곳이 모두 몇 군데인지 자동으로 카운트해주는 객체  
  * 인스턴스가 변수나 상수, 함수의 인자값으로 할당되면 카운트를 1 증가  
  * 해당 변수나 상수들이 종료되면 카운트를 1 감소  
  * 인스턴스의 참조 카운트가 0이 되면 메모리 해제 대상으로 간주 -> 메모리에서 해제  
* 클래스 인스턴스의 비교  
  * 동일 인스턴스인지 비교할 때 : **===**
  * 동일 인스턴스가 아닌지 비교할 때 : **!==**  
```swift
if (video === dvd) {
    print("video와 dvd는 동일한 VideoMode 인스턴스를 참조하고 있군요.")
} else {
    print("video와 dvd는 서로 다른 VideoMode 인스턴스를 참조하고 있군요.")
}

// 실행 결과
video와 dvd는 동일한 VideoMode 인스턴스를 참조하고 있군요.
```
```swift
let vs = VideoMode()
let ds = VideoMode()

if (vs === ds) {
    print("vs와 ds는 동일한 VideoMode 인스턴스를 참조하고 있군요.")
} else {
    print("vs와 ds는 서로 다른 VideoMode 인스턴스를 참조하고 있군요.")
}

// 실행 결과
vs와 ds는 서로 다른 VideoMode 인스턴스를 참조하고 있군요.
```
* **클래스 인스턴스**의 비교 구문을 사용할 때는 값의 비교가 아닌 **메모리 주소의 일치 여부**, 즉 **객체의 동일성 여부**에 근거하게 된다.  

#### 어떤 경우에 구조체를 사용하고, 어떤 경우에 클래스를 사용해야 할까?  
* 클래스와 구조체는 원하는 대로 데이터 형식을 정의하기 위해 사용한다.  
* **구조체**는 **값 자체가 복사 전달**되는 타입  
* **클래스**는 **참조 정보가 전달**되는 타입  
* 다음 조건에 하나 이상 해당하는 경우라면 **구조체**를 사용하는 것이 좋다.  
  * 1. 서로 연관된 몇 개의 기본 데이터 타입들을 캡슐화하여 묶는 것이 목적일 때  
  * 2. 캡슐화된 데이터에 상속이 필요하지 않을 때  
  * 3. 캡슐화된 데이터를 전달하거나 할당하는 과정에서 참조 방식보다는 값이 복사되는 것이 합리적일 때  
  * 4. 캡슐화된 원본 데이터를 보존해야 할 때  
* 여기에 해당하지 않는 경우에는 일반적으로 **클래스**를 정의하여 사용하는 것이 좋다.  
  * 여러 곳에 할당하더라도 **메모리의 낭비가 없다.**  
  * 인스턴스가 늘어나지 않으므로 -> 코딩상에서 혼란이 적다.  